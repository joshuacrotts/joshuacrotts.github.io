<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../../css/pure-min.css" />
  <link rel="stylesheet" href="../../../css/grids-responsive-min.css" />
  <link rel="stylesheet" href="../../../css/style.css" />
  <link rel="icon" type="image/x-icon" href="../../../img/212favicon.ico">

  <title>C212 â€“ Problem Set 3</title>

  <!-- MathJax for formulas -->
  <script>
    MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .math-center {
      text-align: center;
      margin: 1em 0;
    }

    .center-table {
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body>

<div class="ribbon">
  <div class="content">
    <h2>Problem Set 3 - Standard &amp; Tail Recursion</h2>
    <p><strong>Assigned:</strong> January 28, 2026</p>
    <p><strong>Due:</strong> February 4, 2026 at 11:59 PM EST</p>
  </div>
</div>

<div class="ribbon dark">
  <div class="content">
    <h2>Objectives</h2>
    <ul>
      <li>Students learn to design more complex methods.</li>
      <li>Students understand and describe the differences between standard recursion and tail recursion.</li>
      <li>Students design methods that call <code>private</code> helper methods to solve a problem.</li>
    </ul>
  </div>
</div>

<div class="ribbon">
  <div class="content">
    <h2>Instructions</h2>

    <p>
      For each problem, create a class named <code>ProblemX</code>,
      where <code>X</code> is the problem number
      (e.g., <code>Problem1.java</code>).
      Write corresponding JUnit test classes named
      <code>ProblemXTest</code>. 
      Each method must include proper Javadoc comments describing the (1) purpose of the method, (2) parameters, and (3) return value.
      All methods (yes, <i>including helpers</i>) must include proper Javadoc comments describing the (1) purpose of the method, (2) parameters, and (3) return value.
      Helper methods should be marked as <code>private</code>.
      You do not need to write explicit tests for helper methods because they will be indirectly tested through the driver methods.
    </p>
    <p>For problems containing multiple parts, write the methods inside the same class.</p>

    <p>
      <strong>
        Do not round your solutions. For example, do not use
        <code>Math.round</code> or float your output to, e.g.,
        2 decimal places, unless specified.
      </strong>
    </p>
  </div>
</div>

<div class="ribbon dark">
  <div class="content">
    <h2>What You <em>Cannot</em> Use</h2>

    <p>
      You may not use anything beyond Chapter 2.2, and certain parts of Chapter 2 are disallowed.
      This includes but is not limited to:
    </p>

    <ul>
      <li>StringBuilder</li>
      <li>Loops</li>
      <li>Arrays or data structures</li>
      <li>Regular expressions</li>
    </ul>
    <p>
      Any violation results in a score of <strong>0</strong> on the problem set.
    </p>
    <p>
      Please contact a staff member if you are unsure as to whether you're allowed to use something.
    </p>
  </div>
</div>

<div class="ribbon">
    <div class="content">
    <h2>Notes and Version Changes:</h2>
    
    <p><b>Note 1 (01/28):</b> You <i>are</i> allowed to use methods from the <code>Character</code> and <code>Math</code> classes.</p>

    <p><b>Note 2 (01/28):</b> Clarification on Problem 5a: when collecting parenthesized strings, do not include any delimiters between the collected strings.</p>

    <p><b>Note 3 (01/28):</b> Removal of the tail recursive requirement from Problem 8. Fix to method name in autograder.</p>
</div>
</div>

<!-- PROBLEMS -->

<div class="ribbon dark">
  <div class="content problems">
      <h2>Problems</h2>

<ol>
  <li>
    <p>
      Design the <code>boolean isPalindromeTR(String s)</code> tail recursive method, which receives a string and determines
      if it is a palindrome. Recall that a palindrome is a string that is the same backwards as it is
      forwards (e.g., "racecar"). 
      
      </p>
      <p><strong>Warning:</strong> Do not use a (character) array,
      <code>StringBuilder</code>, <code>StringBuffer</code>, or similar, to solve this problem. It
      <em>must</em> be naturally recursive.
    </p>
    <p><u>Files to Submit:</u> <code>Problem1.java</code>, <code>Problem1Test.java</code></p>
  </li>

  <li>
    <p>This problem has two parts.</p>
    <ol type="a">
      <li>
        <p>
          The <em>hyperfactorial</em> of a number, namely \(H(n)\), is the value of
          \(1^1 \cdot 2^2 \cdot \ldots \cdot n^n\). Because the resulting values are outrageously large,
          use the <code>long</code> datatype. Design the standard recursive
          <code>long hyperfactorial(long n)</code> method, which receives a long integer \(n\) and returns its
          hyperfactorial.
        </p>
      </li>
      <li>
        <p>
          Design the tail recursive <code>long hyperfactorialTR(long n)</code> method that uses tail recursion to solve the same problem. 
          You will need to design a <code>private static</code> helper method.
        </p>
      </li>
    </ol>
    <p><u>Files to Submit:</u> <code>Problem2.java</code>, <code>Problem2Test.java</code></p>
  </li>

  <li>
    <p>This problem has two parts.</p>
    <ol type="a">
      <li>
        <p>
          The <em>subfactorial</em> of a number, namely \(!n\), is the number of permutations of \(n\)
          objects such that no object appears in its natural spot. For example, \(!3 = 2\). We define
          subfactorial recursively as:
        </p>
        <p>
\[
!n =
\begin{cases}
  1 & \text{if } n = 0\\
  0 & \text{if } n = 1\\
  (n-1)\cdot\big(!(n-1) + !(n-2)\big) & \text{if } n > 1
\end{cases}
\]
        </p>
        <p>
          Design the standard recursive <code>long subfactorial(long n)</code> method, which receives a long
          integer \(n\) and returns its subfactorial. We once again use the <code>long</code> datatype instead of <code>int</code> to handle larger values.
        </p>
      </li>
      <li>
        <p>
          Design the tail recursive <code>long subfactorialTR(long n)</code> method that uses tail recursion to solve the same problem. 
          You will need to design a <code>private static</code> helper method.
        </p>
      </li>
    </ol>
    <p><i>Hint:</i> if you are getting stuck with the tail recursive version, refer back to the Fibonacci tail recursive method from the textbook!</p>
  
    <p><u>Files to Submit:</u> <code>Problem3.java</code>, <code>Problem3Test.java</code></p>
  </li>

  <li>
    <p>This problem has two parts.</p>
    <ol type="a">
      <li>
        <p>
          Design the standard recursive <code>String collatz(int n)</code> method, which receives a positive
          integer and returns the Collatz sequence, as a string, for that integer:
        </p>
        <p>
          \[
          \texttt{collatz(n)} =
          \begin{cases}
          \texttt{1} & \text{if } n = 1\\
          \texttt{collatz(n / 2)} & \text{if } n \text{ is even}\\
          \texttt{collatz(3 * n + 1)} & \text{if } n \text{ is odd}
          \end{cases}
          \]
        </p>
        <p>
          The sequence continues until it reaches 1. For example,
          <code>collatz(5)</code> returns <code>"5,16,8,4,2,1"</code>.
          <strong>The last number cannot have a comma afterwards.</strong>
        </p>
      </li>
      <li>
        <p>
          Design the tail recursive <code>String collatzTR(int n)</code> method that uses tail recursion to solve the same problem.
          You will need to design a <code>private static</code> helper method.
        </p>
      </li>
    </ol>
    <p><u>Files to Submit:</u> <code>Problem4.java</code>, <code>Problem4Test.java</code></p>
  </li>

  <li>
    <p>This problem has two parts.</p>

    <p>
      A <em>parenthesized string</em> is a string enclosed by parentheses. For example,
      <code>"(abc)pqr(de)"</code> contains two parenthesized strings: <code>"abc"</code> and
      <code>"de"</code>.
    </p>

    <p>
      Assume there are no nested parentheses, all parentheses are balanced, and each parenthesized
      string contains at least one character.
    </p>

    <ol type="a">
      <li>
        <p>
          Design the standard recursive
          <code>String collectParenthesizedStrings(String s)</code> method, which returns a single
          string containing all parenthesized substrings.
          Do not include a delimiter.
          For example, <code>collectParenthesizedStrings("(abc)pqr(de)")</code> returns <code>"abcde"</code>.
        </p>
      </li>
      <li>
        <p>
          Design the tail recursive <code>String collectParenthesizedStringsTR(String s)</code> method that uses tail recursion to solve the same problem.
          You will need to design a <code>private static</code> helper method.
        </p>
      </li>
    </ol>
    <p><u>Files to Submit:</u> <code>Problem5.java</code>, <code>Problem5Test.java</code></p>
  </li>

  <li>
    <p>
      Design the tail recursive
      <code>char findLastNonDigitCharTR(String s)</code> method that returns the last character in
      the string that is not a digit. If no such character exists, return the <code>NUL</code>
      character, i.e., <code>'\0'</code>.
      <!-- You will need to design a <code>private static</code> helper method. -->
    </p>
    <p><u>Files to Submit:</u> <code>Problem6.java</code>, <code>Problem6Test.java</code></p>
  </li>

  <li>
    <p>Consider the following data definitions:</p>
    <pre>
      A BooleanLiteral is one of:
        - "T"
        - "F"

      A BooleanLiteralAtom is one of:
        - BooleanLiteral
        - "!" + BooleanLiteral

      A BooleanExpression is one of:
        - BooleanLiteralAtom
        - BooleanExpression + "&amp;" + BooleanExpression
        - BooleanExpression + "|" + BooleanExpression
    </pre>
    <p>We evaluate a <code>BooleanExpression</code> as follows: when we encounter a <code>"!"</code>, flip the immediately-following boolean value.
    When we encounter a <code>"&amp;"</code>, take the left boolean value and recurse on the right side, then return the logical AND of the two values.
    When we encounter a <code>"|"</code>, take the left boolean value and recurse on the right side, then return the logical OR of the two values.
  </p>
    <p>For example, evaluating <code>"!T&F|T"</code> means we first negate <code>T</code> to get <code>F</code>, then we encounter <code>&amp;</code>, so we recurse on the rest of the string to evaluate <code>"F|T"</code>. We encounter <code>|</code>, so we recurse on the rest of the string to evaluate <code>"T"</code>, which resolves to <code>true</code>. As the recursion unwinds, we evaluate <code>false || true</code> to get <code>true</code>, then <code>false &amp;&amp; true</code> to get <code>false</code>.</p>
    <p>This order of evaluation is right-associative, i.e., it's as if <code>"!T&F|T"</code> has implicit parentheses as <code>("!T")&("F"|("T"))</code>.</p>
      <p>
          Design the standard recursive
          <code>boolean evaluateBooleanExpression(String expr)</code> method that evaluates a
          given boolean expression according to the above data definition.
          Therefore, you may assume that the input is always a valid <code>BooleanExpression</code>.
      </p>
      <p><i>Hint 1:</i> this problem is pretty difficult to solve, and we would strongly recommend you not wait until the last minute to start working on it.</p>
      <p><i>Hint 2:</i> consider this a case analysis on the length of the string: if the string is length 1, what do you know about it? If it is length 2, what do you know about it? If it has more than 2 characters, what do you know about it?</p>
      <p><i>Hint 3:</i> obviously, the hardest part of this problem is handling the case where there are more than 2 characters, e.g., with a binary operator, because there's the inherent possibility of a negated <code>BooleanLiteral</code>, which must be handled prior to the binary operator evaluation.</p>

      <p><u>Files to Submit:</u> <code>Problem7.java</code>, <code>Problem7Test.java</code></p>
  </li>
</ol>

  </div>
</div>

</body>
</html>
